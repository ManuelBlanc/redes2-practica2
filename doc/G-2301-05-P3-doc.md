
# Redes 2 -- Práctica 3: Añadir SSL a las comunicaciones entre el cliente y el servidor

## Introducción

El objetivo de esta práctica es implementar la opción de una comunicación segura entre cliente y servidor a través de SSL.

### Como compilar
Para compilar el servidor, se adjunta un fichero `G-2301-05-P3-autogen.sh` que genera los ficheros necesarios para efectuar la compilación con autotools.
Después, se debe ejecutar:

    make

Para compilar nuestro cliente de la práctica 1 con soporte SSL hay que estar en el directorio cliente_SSL y ejecutar:

    make -f ./G-2301-05-makefile

## Diseño

En esta sección están documentadas las decisiones de diseño tomadas en el desarrollo.

### Módulos del programa

Los módulos de esta práctica respetan la separación de las prácticas anteriores.

### Descripción y diseño

Hemos implementado las funciones que conforman la librería de SSL y para un mejor manejo hemos creado las siguientes estructuras:

        struct Redes2_SSL_CTX {
	        const SSL_METHOD*  connection_method;
	        SSL_CTX*     ctx;
        };

        struct Redes2_SSL {
        	SSL* ssl;
        };

Estas estructuras nos permiten condensar algunas líneas de código y abstraer los distintos módulos del programa de las funciones de openssl. El campo SSL_METHOD lo pusimos en la estructura porque el pdf decía que sería usado más de una vez, pero no ha sido nuestro caso.

La implementación de una librería que trata con openssl aporta más independencia a nuestros cliente y servidor. Así si decidiéramos cambiar la implementación segura solo habría que modificar un fichero. Mucho más limpio que bucear entre líneas de código por múltiples ficheros.

En esta práctica hemos encontrado y arreglado errores de la práctica anterior. Por ejemplo nos hemos dado cuenta de que al crear un nuevo usuario lo añadíamos a la lista más de una vez. Esto afectaba a la eliminación de usuarios que tampoco funcionaba correctamente por esta razón.
El arranque de esta práctica es distinto a las anteriores. Existe un main en el que se crea el servidor y sus dos hilos (puerto seguro/no seguro). Tras esta operación el hilo del main muere y solo quedan en ejecución los otros dos que serán los usados por el servidor.  
El sistema de envío de pings lo hemos cambiado resecto a la entrega anterior porque encontramos una modo que era más sencillo y nos daba menos problemas. Antes era el servidor el encargado de mandar los pings a todos los usuarios que estuvieran en el sistema para comprobar la actividad. Sin embargo encontramos útil que fuera el propio hilo de recepción del usuario el que se mandara un ping a sí mismo. En concreto elsitema funciona de la siguiente manera.
Está pensado para detectar la inactividad, es decir, mandamos un ping cuando el usuario ha estado un tiempo sin actividad, no mandamos pings cada unos cuantos segundos periódicamente.
El hilo de recepción quedará bloquedao en el recv() como máximo 10 segundos. Si se recibe algún comando en un tiempo menor se realizarán las acciones pertinente y volverá a quedar bloqueado en recv(). Si no se recibe nada en 10 segundos entonces se mandará un ping al usuario, esto lo que hace es borrar una flag del usario que solo se restaura si este responde al servidor con un pong. Si el usuario sigue sin tener actididad y no responde al pong en otros 10 segundo se mandará otro ping y si el usario no tiene dicha flag será expulsado del servidor.

Hemos decidido hacer una implementación en la que convivan las conexiones seguras y no seguras. Nuestro servidor acepta conexiones simultáneamente en el puerto 6667 para conexiones no seguras y en el 6697 para seguras. Una funcionalidad que le hemos añadido es poder cambiar el número de los puertos por los que escuchará las conexiones seguras y no seguras con una flag. Para ejecutar esta opción se haría de la siguiente manera:
        ./G-2301-05-P3-server -p#puertonoseguro -s#puertoseguro


## Conclusiones técnicas

Una de las dificultades encontradas en el desarrollo ha sido lidiar con los RFCs:

Uno de los problemas, no más complicados, pero sí que a la larga terminan consumiendo más tiempo ha sido tratar con los RFCs. El problema no ha sido su comprensión en la mayoría de los casos sino las diferencias entre ellos. Como por ejemplo errores que se encuentran en un RFC en el otro están obsoletos.
Un hecho que en particular nos llamó la atención es que el RFC no se modifica a lo largo del tiempo si no que tiene un enlace a otro documento en el que se listan los errores de RFC corregido. En nuestro caso es relevante ya que encontramos que en la respuesta del invite los argumento debían mandarse en el orden inverso al especificado en el RFC2812.
Además, hay pequeñas diferencias entre los RFC1459 y RFC2812, como el formato del mensaje `USER` y la longitud máxima de un nombre de canal.

El comando `MODE` es uno de los que más peso de programación requieren ya que primero hay que diferenciar si invoca alguna bandera y si es así diferenciar si esta afecta a un canal o aun usuario.
Si afecta a un canal tendremos que distinguir si afecta a las propiedades de un canal o a un usuario dentro del canal. Esta es la parte de parseo. Cuando sabemos a que va a afectar hay que cambiar las banderas correspondientes cuidadosamente y enviar un mensaje de respuesta.
Esta función implica la implementación muchas otras funcionalidades.

## Conclusiones personales

El desarrollo de esta práctica ha superado con creces el tiempo pronosticado en la guía docente. Los objetivos de la asignatura abarcan mucho más allá del uso de sockets en C. Usando la métrica de lineas de código, la programación con sockets representa aproximadamente un 3% del total de código. El 97% restante lo compone el tratamiento de cadenas, manejo de hilos, interacción con la librería y el código relacionado con la interfaz gráfica. Además, esta métrica no incluye todo el trabajo de planificación, estudio de documentación, lectura de RFCS y elaboración de la documentación exigida.

Se suma el trabajo adicional de instalar e interactuar el paquete proporcionado. En las primeras semanas de laboratorio de la practica 1 se encontraron numerosas dificultades al instalar los paquetes. La librería se ha distribuido empaquetada en un paquete `.deb`, por lo que fue ineludible la necesidad de tener acceso a un Debian o tener que desplazarse hasta la universidad para usar uno de los ordenadores de los laboratorios 11 o 12, los únicos en los que están los paquetes instalados y que pueden estar ocupados por otra asignatura.

Al no disponer del código fuente, ha habido que hacer ingeniería inversa para averiguar el comportamiento exacto de algunas funciones, como por ejemplo, el MODE. El parser de este comando no satisface completamente la estructura del comando según los RFCs, puesto que no permite proporcionar múltiples argumentos para las banderas `l` y `k`. Otros problemas encontrados han sido que la librería no usa `const`, y por tanto, nuestro programa no puede usarlos si quiere interactuar con ella; y que la función `UnPipeline` produce errores en valgrind (en conreto: conditional jump or move depends on uninitialized value(s)) y más de una vez ha ocurrido un fallo de segmentación dentro de esa función que ha sido imposible de depurar. Muchos pequeños detalles como estos han consumido bastante tiempo.

Otro problema ha sido la NO-publicación de unos criterios claros de corrección. A la hora de guiar el desarrollo, hemos seguido nuestra intuición de que comandos nos parecían más importantes. Desarrollar un proyecto de esta magnitud sin ninguna idea de que se espera ha sido algo bastante frustrante.

C es un lenguaje muy poco permisivo para los errores. Un error trivial de memoria puede causar muchísimo daño (eg., heartbleed). Kurose escoje Java para ilustrar los ejemplos de su libro ya que se necesitan muchas menos lineas de codigo para hacer lo mismo que en un programa C. Cuando la velocidad no prima, no hay ventajas de usar C.

La conclusión es que estas practicas han resultado muchísimo trabajo por nuestra parte, y el producto ni siquiera es un servidor que pueda ser usado ya que no esta suficientemente probado y podria ser potencialmente inseguro.
