
# Redes 2 -- Práctica 3: Añadir SSL a las comunicaciones entre el cliente y el servidor

## Introducción

El objetivo de esta práctica es implementar la opción de una comunicación segura entre cliente y servidor a través de SSL.

### Como compilar
Para compilar el servidor, se adjunta un fichero `G-2301-05-P3-autogen.sh` que genera los ficheros necesarios para efectuar la compilación con autotools.
Después, se debe ejecutar:

    make

Para compilar nuestro cliente de la práctica 1 con soporte SSL hay que estar en el directorio cliente_SSL y ejecutar:

    make -f ./G-2301-05-makefile

## Diseño

En esta sección están documentadas las decisiones de diseño tomadas en el desarrollo.

### Módulos del programa

Los módulos de esta práctica respetan la separación de las prácticas anteriores.

### Descripción y diseño

Hemos implementado las funciones que conforman la librería de SSL y para un mejor manejo hemos creado las siguientes estructuras:

        struct Redes2_SSL_CTX {
	        const SSL_METHOD*  connection_method;
	        SSL_CTX*     ctx;
        };

        struct Redes2_SSL {
        	SSL* ssl;
        };

La implementación de una librería que tarta con openssl aporta más independencia a nuestro cliente y servidor. Así si decidieramos cambiar la implemenación segura


## Conclusiones técnicas

Una de las dificultades encontradas en el desarrollo ha sido lidiar con los RFCs:

Uno de los problemas, no más complicados, pero sí que a la larga terminan consumiendo más tiempo ha sido tratar con los RFCs. El problema no ha sido su comprensión en la mayoría de los casos sino las diferencias entre ellos. Como por ejemplo errores que se encuentran en un RFC en el otro están obsoletos.
Un hecho que en particular nos llamó la atención es que el RFC no se modifica a lo largo del tiempo si no que tiene un enlace a otro documento en el que se listan los errores de RFC corregido. En nuestro caso es relevante ya que encontramos que en la respuesta del invite los argumento debían mandarse en el orden inverso al especificado en el RFC2812.
Además, hay pequeñas diferencias entre los RFC1459 y RFC2812, como el formato del mensaje `USER` y la longitud máxima de un nombre de canal.

El comando `MODE` es uno de los que más peso de programación requieren ya que primero hay que diferenciar si invoca alguna bandera y si es así diferenciar si esta afecta a un canal o aun usuario.
Si afecta a un canal tendremos que distinguir si afecta a las propiedades de un canal o a un usuario dentro del canal. Esta es la parte de parseo. Cuando sabemos a que va a afectar hay que cambiar las banderas correspondientes cuidadosamente y enviar un mensaje de respuesta.
Esta función implica la implementación muchas otras funcionalidades.

## Conclusiones personales

El desarrollo de esta práctica ha superado con creces el tiempo pronosticado en la guía docente. Los objetivos de la asignatura abarcan mucho más allá del uso de sockets en C. Usando la métrica de lineas de código, la programación con sockets representa aproximadamente un 3% del total de código. El 97% restante lo compone el tratamiento de cadenas, manejo de hilos, interacción con la librería y el código relacionado con la interfaz gráfica. Además, esta métrica no incluye todo el trabajo de planificación, estudio de documentación, lectura de RFCS y elaboración de la documentación exigida.

Se suma el trabajo adicional de instalar e interactuar el paquete proporcionado. En las primeras semanas de laboratorio de la practica 1 se encontraron numerosas dificultades al instalar los paquetes. La librería se ha distribuido empaquetada en un paquete `.deb`, por lo que fue ineludible la necesidad de tener acceso a un Debian o tener que desplazarse hasta la universidad para usar uno de los ordenadores de los laboratorios 11 o 12, los únicos en los que están los paquetes instalados y que pueden estar ocupados por otra asignatura.

Al no disponer del código fuente, ha habido que hacer ingeniería inversa para averiguar el comportamiento exacto de algunas funciones, como por ejemplo, el MODE. El parser de este comando no satisface completamente la estructura del comando según los RFCs, puesto que no permite proporcionar múltiples argumentos para las banderas `l` y `k`. Otros problemas encontrados han sido que la librería no usa `const`, y por tanto, nuestro programa no puede usarlos si quiere interactuar con ella; y que la función `UnPipeline` produce errores en valgrind (en conreto: conditional jump or move depends on uninitialized value(s)) y más de una vez ha ocurrido un fallo de segmentación dentro de esa función que ha sido imposible de depurar. Muchos pequeños detalles como estos han consumido bastante tiempo.

Otro problema ha sido la NO-publicación de unos criterios claros de corrección. A la hora de guiar el desarrollo, hemos seguido nuestra intuición de que comandos nos parecían más importantes. Desarrollar un proyecto de esta magnitud sin ninguna idea de que se espera ha sido algo bastante frustrante.

C es un lenguaje muy poco permisivo para los errores. Un error trivial de memoria puede causar muchísimo daño (eg., heartbleed). Kurose escoje Java para ilustrar los ejemplos de su libro ya que se necesitan muchas menos lineas de codigo para hacer lo mismo que en un programa C. Cuando la velocidad no prima, no hay ventajas de usar C.

La conclusión es que estas practicas han resultado muchísimo trabajo por nuestra parte, y el producto ni siquiera es un servidor que pueda ser usado ya que no esta suficientemente probado y podria ser potencialmente inseguro.
