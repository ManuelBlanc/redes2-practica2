
\documentclass[12pt, a4paper]{memoriaeps}

\asignatura{Redes de comunicaciones 2}
\curso{2015}
\universidad{UAM}
\practica{1}{Diseño e implementación de un cliente IRC}
\autores{
\href{mailto:ana.alonsoa@estudiante.uam.es}{A. Alonso}
\href{mailto:manuel.blanc@estudiante.uam.es}{M. Blanc}
}

\begin{document}

\portada{\vfill\imagen[0.2]{../../res/icon.png}\vspace{5cm}}
\indice{}

\seccion{Introducción}

Esta memoria detalla el diseño y las decisiones tomadas a lo largo del desarrollo de la práctica. El objetivo de esta práctica ha sido el diseño y programación de un cliente IRC con unas características similares a las de xchat. Estos han sido nuestros objetivos principales:

\begin{itemize}
	\item Poder unirse a un canal, enviar y recibir mensajes de otros usuarios.
	\item Comandos IRC básicos: manejo de modos, tema, de información e ignore.
	\item Transmisión y recepción de ficheros.
\end{itemize}

\paragraph{Comentario} Por brevedad, nos referiremos a los ficheros por su nombre sin el prefijo obligatorio, eg. \fichero{chat_funcs.c} en vez de \fichero{G-2301-05-P1-chat_funcs.c}.

\subseccion{Organización del proyecto}
El proyecto esta organizado de la siguiente forma:

\begin{grupotablas}
	\begin{tabla}[Organización lógica en disco]{ll}
		\fichero{doc/}              	& Memoria y el texto del manual	\\
		\fichero{includes/}         	& Cabeceras                    	\\
		\fichero{lib/}              	& Librerías                    	\\
		\fichero{man/}              	& Paginas de manual generadas  	\\
		\fichero{obj/}              	& Objetos intermedios generados	\\
		\fichero{scripts/}          	& Utilidades adicionales       	\\
		\fichero{src/}              	& Fuentes del ejecutable       	\\
		\fichero{srclib/}           	& Fuentes de la librería       	\\
		\fichero{G-2301-05-makefile}	& Makefile del proyecto        	\\
	\end{tabla}
\end{grupotablas}

Reconocemos las siguientes tres ventajas:
\begin{itemize}
	\item Facilita la instalación: basta con copiar los contenidos de \fichero{includes/}, \fichero{lib/} y \fichero{man/} a su equivalente en \fichero{/usr/local/}.
	\item Todos los ficheros intermedios generados están reunidos en la carpeta \fichero{obj/}.
	\item Los fuentes de la librería y los del ejecutable estan separados en los directorios \fichero{src/} y \fichero{srclib/}. Esta separación permite sustituir más fácilmente la interfaz por otra distinta (eg, basada en curses).
\end{itemize}

Sin embargo, esta organización ha tenido como precio una mayor complejidad del \fichero{makefile}, teniendo que crear varias reglas de substitución para poder generar los objetos en una carpeta diferente a la de los fuentes.

\subseccion{Objetivos de compilación}
Estos son los objetivos implementados en el makefile:
\begin{description}
	\item[\codigo{all}]   Compila, crea la librería y construye el ejecutable.
	\item[\codigo{docs}]  Crea las páginas de manual de las funciones públicas.
	\item[\codigo{clean}] Elimina las librerías creadas en la compilación, los \codigo{.o} y el ejecutable.
	\item[\codigo{dist}]  Primero ejecuta \codigo{clean} y luego comprime el proyecto en formato \codigo{.tgz}.
	\item[\codigo{help}]  Imprime una ayuda similar a esta.
	\item[\codigo{info}]  Imprime por pantalla información sobre los objetivos y banderas de compilación.
\end{description}

% \seccion{Manual de uso}
% Para conectarse a un servidor hay que rellenar al menos los campos de nick, servidor y puerto.
% Una vez conectado, se puede usar el comando \codigo{/join \#canal} para unirse a un canal.

\seccion{Consideraciones de diseño}

Nuestra implementación esta basada en comandos de texto. Todas las interacciones con la interfaz funcionan usando comandos de texto y proporciona una interfaz a nuestra librería homogénea.

\subseccion{Organización de los fuentes}

Hemos estructurado los fuentes de la siguiente manera,
\begin{itemize}
	\item \fichero{chat.c}      	contiene el \funcion{main} y la interfaz gráfica.
	\item \fichero{chat_funcs.c}	tiene los manejadores de la interfaz.
	\item \fichero{client.c}    	gestiona el socket IRC encapsulado en una estructura.
	\item \fichero{clientcmd.c} 	procesa los comandos de usuario.
	\item \fichero{clientrpl.c} 	procesa las respuestas del servidor.
	\item \fichero{clientfile.c}	implementa el envío y recepción de ficheros.
	\item \fichero{util.c}      	contiene rutinas para ayudarnos con la codificación.
\end{itemize}

\subseccion{Macros auxiliares}

En \fichero{util.c} se definen las macros \funcion{LOG} y \funcion{ASSERT}. La primera imprime por \codigo{stderr} un texto formateado y prefijado con el nombre de fichero y la linea. Hemos hecho extenso uso durante el desarrollo para imprimir trazas y ayudarnos a depurar el programa.
Al tratarse de una macro, puede ser redefinida fácilmente para que desaparezca al compilar una versión que no sea de desarrollo. La macro \funcion{ASSERT} comprueba que una condición sea cierta, y cierra el programa con un error si no se cumple. La usamos para errores no recuperables. Hemos tomado esta decisión de diseño porque pensamos que es preferible cerrar el programa con un error a dejarlo en un estado inconsistente, potencialmente perdiendo datos.

\subseccion{Tipos de datos}

El tipo de datos principal que usa la librería es \codigo{Client*}. Hemos optado por la utilización de una estructura porque creemos que encapsular la información ligada con el cliente es útil y agiliza los accesos a ella. Ademas, facilita en un futuro la posibilidad de tener múltiples clientes corriendo en el mismo programa. A continuación hay un listado de código con los campos de esta estructura.
\begin{lstlisting}[basicstyle=\scriptsize]
typedef struct Client {
	char         buf[IRC_MAX_CMD_LEN+1];                   // Buffer de recepcion
	char         cmd[IRC_MAX_CMD_LEN+1];                   // Buffer para el comando
	char         pre[IRC_MAX_PRE_LEN+1];                   // Prefijo
	char         nick[IRC_MAX_NICK_LEN+1];                 // Nickname
	char*        serv;                                     // Servidor
	unsigned int port;                                     // Puerto
	char*        name;                                     // Nombre
	char*        rname;                                    // Nombre real
	char         ignored[NUM_MAX_IGN][IRC_MAX_NICK_LEN+1]; // Lista de ignorados
	int          sock_fd;                                  // Descriptor del socket
	pthread_t    thr;                                      // Hilo de recepcion
} Client;
\end{lstlisting}
Los campos están aproximadamente ordenados de mayor a menor tamaño para evitar que el compilador inserte padding en la estructura.

\subseccion{Conexión y desconexión}
A la hora de conectarnos realizamos los siguientes pasos. Primero creamos el socket. Después rellenamos la estructura necesaria para realizar la conexión con el nombre del servidor, el puerto, y la dirección del servidor con el que nos queremos conectar. Una vez creada esta estructura con los valores necesarios llamamos a \funcion{connect}. Antes de enviar el handshake inicial, inicializamos el hilo de recepción. Por último mandamos dos comandos: \codigo{NICK} y \codigo{USER}, para establecer la información que nos identificará en el servidor. Después de este proceso, el servidor enviara datos sobre su funcionamiento al cliente, verificado que la conexión ha sido establecida exitosamente.

Para la desconexión, se envía un mensaje de cierre (\codigo{QUIT}), se cierra el socket y se espera a que finalice el hilo de recepción.

\subseccion{Envío y recepción}
La función que hemos utilizado para enviar, \funcion{client_send_cmd}, utiliza por dentro \funcion{sendto}. Los dos últimos argumentos tienen un valor nulo porque son ignorados y elegimos esta función porque está orientada a conexión. Para la recepción tenemos una función llamada \funcion{receive} en la que se encuentra un \codigo{while(1)} donde se ejecuta el hilo de recepción que está recibiendo paquetes o a la espera de ellos. La función principal que ejecuta es \funcion{recvfrom}.

En los \codigo{switch}, tanto el de envío como el de recepción, hemos decidido llamar en cada \codigo{case} a una función en vez de poner el código directamente. Hemos hecho esto así para facilitar el poner y quitar comandos

\subseccion{Implementación de los comandos}
Nuestra implementación se basa comandos de texto. Las interacciones con la interfaz generan un comando que es procesado por \codigo{clientcmd}. La ventaja de esta implementación es que tenemos una interfaz de nuestra librería consistente, y evitamos las redundancias. Una desventaja de esta implementación es que es ligeramente más lenta.


La mayoría de funciones en \funcion{clientcmd} tienen la misma estructura. Primero se parsea la entrada del usuario, luego se crea el mensaje que va a ser enviado al servidor y por último se llama a la función \funcion{client_send_cmd} para enviar el mensaje.

Hay dos puntos de entrada para ejecutar un comando: \codigo{clientcmd} y \codigo{clientcmdf}. Hacemos uso extenso del segundo para generar y ejecutar comandos sobre la marcha.


\subseccion{Transmisión de ficheros}

En primer lugar, habíamos pensado hacer la transferencia de ficheros sobre mensajes privados. Cuando un usuario desease mandar a otro un fichero, le mandara varios mensajes privados con bloques del fichero. Para poder transferir datos binarios arbitrarios, los bloques se codificaban en base 64. La principal ventaja de esta implementación es que funciona entre pares que están detrás de NATs. Sin embargo, tiene varios inconvenientes:

\begin{itemize}
	\item La conversión a base 64 expande cada \bytes{3} a \bytes{4}, un aumento del 33\%.
	\item Al encapsularlo en un mensaje IRC, hay un sobrecoste de al menos unos \bytes{30} aproximadamente. Por tanto, por cada mensaje se pueden enviar a lo sumo \bytes{480}.
	\item El servidor o el cliente puede limitar la velocidad a la que atiende los mensajes para evitar la congestión.
\end{itemize}

Con estas estimaciones, un fichero \kilobytes{360} sera expandido hasta \kilobytes{480} al convertirse en base 64. Deberá ser enviado en $1024$ paquetes. A un ritmo de procesamiento de $4$ paquetes por segundo, se tardaran $256 s$ o $4$ minutos para un fichero relativamente pequeño. Este tiempo tan grande nos pareció inaceptable.

Al final, nos hemos decantado por una conexión directa. El handshake lo hemos implementado de acuerdo con nuestra interpretación del protocolo DCC.

La transferencia de ficheros se hace a través de los comandos \codigo{/fsend}, \codigo{/faccept}, \codigo{/fcancel}. La implementación esta en el fichero \fichero{clientfile.h}, y sigue vagamente la especificación DCC.

\subseccion{Modificaciones de la interfaz gráfica}
Hemos hecho algunos pequeños cambios sobre la interfaz,
\begin{itemize}
	\item Los campos de texto se bloquean al conectarse.
	\item Hemos añadido un icono a la aplicación.
	\item Fijado el tamaño de la ventana (para que no se pueda agrandar).
	\item Los checkboxes se marcan automáticamente cuando se recibe un \codigo{MODE} del servidor.
\end{itemize}

\seccion{Conclusiones}

\subseccion{Técnicas}

Trabajar con sockets BSD se ha asemejado bastante a trabajar con FIFOs, por lo que nos ha resultado familar a lo visto en la asignatura de Sistemas Operativos. La mayor parte del trabajo con sockets ha sido mirar la documentación. En particular, las diferentes estructuras usadas y los matices entre ellas (dirección ``general'' vs. dirección IPv4).

Hemos unificado todo lo que podimos los diferentes aspectos del programa. Nuestro programa pasó por varias fases hasta que conseguimos llegar a un diseño satisfactorio. Empleamos tiempo en leer la documentación hasta que comprendimos cual era el uso de cada comando, ya que estos comandos no están estandarizados.

Otra dificultad encontrada ha sido el uso del lenguaje de programación C. Es un lenguaje de medio-bajo nivel imperativo. Para programar una función, es necesario bastante mas código que en otros lenguajes de programación ya que hay que decirle a la máquina todos los pasos a seguir. Por un lado, esto da mas control sobre lo que está ocurriendo, pero como consecuencia requiere más tiempo de programación. Algunos ejemplos:

\begin{itemize}
	\item No hay una manera completamente limpia de manejar los errores (eg, \funcion{socket} devuelve \codigo{-1}, \funcion{malloc} devuelve \codigo{NULL}).
	\item Hay que estar constantemente comprobando las longitudes para no hacer overflow (las consecuencias pueden ser catastróficas y difíciles de debugear si se sobrescribe otra memoria).
	\item Valgrind ha sido de poco uso porque GTK internamente da muchos falsos positivos.
\end{itemize}

\subseccion{Personales}

Para hacer el proyecto, lo hemos hecho los dos juntos en programación en pareja (pair programming). A lo largo del desarrollo hemos intercambiado lo que estábamos haciendo. Revisábamos constantemente lo que estaba haciendo el otro y así encontramos muchos errores. Al tratarse de un proyecto mediano, no ha hecho falta especializarse y los dos hemos podido comprender todo el proyecto. Otra ventaja es que hemos podido aplicar cosas que aprendíamos del código del otro en que escribíamos después.

En esta práctica nos hemos dado cuenta de que el uso de librerías sin documentación ha sido un detrimento para el desarrollo. Hemos tenido que hacer ingeniera inversa para averiguar que hacían algunas funciones. Además, algunos bugs no sabíamos si provenían de nuestro código, o del proporcionado.

Quizás diríamos que la carga de trabajo esta en leer manuales, entender su librería y en escribir estas documentaciones.




\begin{thebibliography}{9}

\bibitem{rfc2812}
\textit{Internet Relay Chat: Client Protocol},
\\\texttt{https://tools.ietf.org/html/rfc2812}

\bibitem{irchelp}
\textit{RFC: Internet Relay Chat Protocol}
\\\texttt{http://www.irchelp.org/irchelp/rfc/}

\bibitem{wikipedia}
\textit{Direct Client-to-Client}
\\\texttt{http://en.wikipedia.org/wiki/Direct_Client-to-Client}

\end{thebibliography}


\end{document}
